generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum QuestStatus {
  draft
  active
  completed
  failed
  archived
}

enum ThemePreference {
  light
  dark
  auto
}

model User {
  id             String          @id @default(cuid())
  email          String          @unique
  password       String?
  name           String?
  avatarUrl      String?
  themePreference ThemePreference @default(light)
  quests         Quest[]
  investigations TaskInvestigation[]
  roles          UserRole[]
  assignedRoles  UserRole[]      @relation("UserRoleAssignedBy")
  auditEntries   AdminAuditLog[] @relation("AuditActor")
  accounts       OAuthAccount[]
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt
}

model Quest {
  id          String   @id @default(cuid())
  ownerId     String
  title       String
  modelType   String   @default("gpt-4o-mini")
  goal        String?
  context     String?
  constraints String?
  isPublic    Boolean  @default(false)
  status      QuestStatus @default(draft)
  deletedAt   DateTime?
  tasks       Task[]
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  owner       User     @relation(fields: [ownerId], references: [id])
}

model Task {
  id        String @id @default(cuid())
  questId   String
  title     String
  details   String?
  extraContent String?
  order     Int
  status    String @default("todo") // todo, in-progress, done
  createdAt DateTime @default(now())
  quest     Quest  @relation(fields: [questId], references: [id])
  investigations TaskInvestigation[]
}

model TaskInvestigation {
  id            String   @id @default(cuid())
  taskId        String
  status        String   @default("pending")
  modelType     String   @default("gpt-4o-mini")
  summary       String?
  details       String?
  error         String?
  prompt        String?
  initiatedById String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  task          Task     @relation(fields: [taskId], references: [id], onDelete: Cascade)
  initiatedBy   User?    @relation(fields: [initiatedById], references: [id])

  @@index([taskId])
  @@index([createdAt])
}

model Role {
  id          String   @id @default(cuid())
  name        String   @unique
  description String?
  system      Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  users       UserRole[]
  privileges  RolePrivilege[]
}

model Privilege {
  id          String   @id @default(cuid())
  key         String   @unique
  label       String
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  roles       RolePrivilege[]
}

model RolePrivilege {
  roleId      String
  privilegeId String
  assignedAt  DateTime @default(now())
  role        Role      @relation(fields: [roleId], references: [id], onDelete: Cascade)
  privilege   Privilege @relation(fields: [privilegeId], references: [id], onDelete: Cascade)

  @@id([roleId, privilegeId])
}

model UserRole {
  userId        String
  roleId        String
  assignedById  String?
  assignedAt    DateTime @default(now())
  user          User @relation(fields: [userId], references: [id], onDelete: Cascade)
  role          Role @relation(fields: [roleId], references: [id], onDelete: Cascade)
  assignedBy    User? @relation("UserRoleAssignedBy", fields: [assignedById], references: [id])

  @@id([userId, roleId])
  @@index([roleId])
}

model AdminAuditLog {
  id         String   @id @default(cuid())
  actorId    String?
  action     String
  targetType String
  targetId   String?
  metadata   Json?
  createdAt  DateTime @default(now())

  actor User? @relation("AuditActor", fields: [actorId], references: [id], onDelete: SetNull)

  @@index([createdAt])
  @@index([targetType, targetId])
}

model OAuthAccount {
  id                 String   @id @default(cuid())
  provider           String
  providerAccountId  String
  userId             String
  accessToken        String?
  refreshToken       String?
  expiresAt          DateTime?
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt
  user               User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}
